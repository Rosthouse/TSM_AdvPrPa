module ParserCombisExt
  (Parser,
   failureP, epsilonP, itemP, satP,
   (+++), optC, rep0C, rep1C, sepList0C, sepList1C, lAssoC, rAssoC, nonAssoC,
   topLevelC)
where

infixr 5 +++

-- suffix P indicates a parser
-- suffix C indicates a parser combinator

newtype Parser t a = P ([t] -> [(a, [t])])

parse :: Parser t a -> [t] -> [(a, [t])]
parse (P p) toks = p toks

instance Monad (Parser t) where
  return v = P (\toks -> [(v, toks)])
  p >>= f = P (\toks -> case parse p toks of
                          [] -> []
                          [(v, remToks)] -> parse (f v) remToks)

failureP :: Parser t a
failureP = P (\toks -> [])

epsilonP :: Parser t [a]
epsilonP = return []

itemP :: Parser t t
itemP = P (\toks -> case toks of
                      [] -> []
                      (tok : remToks) -> [(tok, remToks)])

satP :: (t -> Bool) -> Parser t t
satP p = do tok <- itemP; if p tok then return tok else failureP

(+++) :: Parser t a -> Parser t a -> Parser t a
p +++ q = P (\toks -> case parse p toks of
                        [] -> parse q toks
                        [(v, remToks)] -> [(v, remToks)])

optC :: Parser t a -> Parser t (Maybe a)
optC elemP =
      (do e <- elemP; return (Just e))
  +++ (do epsilonP;   return Nothing)

rep0C :: Parser t a -> Parser t [a]
rep0C p = rep1C p +++ epsilonP

rep1C :: Parser t a -> Parser t [a]
rep1C p = do v <- p; vs <- rep0C p; return (v : vs)

sepList1C :: Parser t a -> Parser t b -> ([a] -> c) -> Parser t c
sepList1C elemP sepP f =
  do e  <- elemP
     es <- rep0C (do sepP; e <- elemP; return e)
     return (f (e : es))

sepList0C :: Parser t a -> Parser t b -> ([a] -> c) -> Parser t c
sepList0C elemP sepP f = sepList1C elemP sepP f +++ return (f [])

-- suited for left-associative operators
-- (though generated by right-associative parsing)
type InfixL term opr = (term, [(opr, term)])
-- suited for right-associative operators
type InfixR term opr = ([(term, opr)], term)

l2r :: InfixL term opr -> InfixR term opr
l2r (tl, (opr, tr) : ots) = ((tl, opr) : tos, t)
  where (tos, t) = l2r (tr, ots)
l2r (t, []) = ([], t)

test_l2r =
  l2r (1, [('+',2),('-',3),('*',4)]) == ([(1,'+'),(2,'-'),(3,'*')],4) &&
  l2r (1, []) == (([], 1) :: InfixR Int Char)

type Node opr term = opr -> term -> term -> term
type Convert term opr = Node opr term -> InfixL term opr -> term

infixC :: Convert term opr ->
            Parser t term -> Parser t opr -> Node opr term -> Parser t term
infixC convert termP oprP node =
  do term     <- termP
     oprTerms <- rep0C (do opr <- oprP; term <- termP; return (opr, term))
     return ((convert node) (term, oprTerms))

lAsso :: Convert term opr
lAsso node (term, oprTerms) =
  foldl (\tl (opr, tr) -> node opr tl tr) term oprTerms

lAssoC :: Parser t term -> Parser t opr -> Node opr term -> Parser t term
lAssoC = infixC lAsso

rAsso :: Convert term opr
rAsso node infixL =
  foldr (\(tl, opr) tr -> node opr tl tr) term termOprs
    where (termOprs, term) = l2r infixL

rAssoC :: Parser t term -> Parser t opr -> Node opr term -> Parser t term
rAssoC = infixC rAsso

nonAssoC :: Parser t term -> Parser t opr -> Node opr term -> Parser t term
nonAssoC termP oprP node =
  do term       <- termP
     optOprTerm <- optC (do opr <- oprP; term' <- termP; return (opr, term'))
     return (case optOprTerm of
               Nothing -> term
               Just (opr, term') -> node opr term term')

{-
-- lAssoC and rAssoC in somewhat less higher order
infixC :: Parser t term -> Parser t opr -> Parser t (InfixL term opr)
infixC termP oprP =
  do term     <- termP
     oprTerms <- rep0C (do opr <- oprP; term <- termP; return (opr, term))
     return (term, oprTerms)

lAssoC :: Parser t term -> Parser t opr -> Node opr term -> Parser t term
lAssoC termP oprP node =
  do (term, oprTerms) <- infixC termP oprP
     return (foldl (\tl (opr, tr) -> node opr tl tr) term oprTerms)

rAssoC :: Parser t term -> Parser t opr -> Node opr term -> Parser t term
rAssoC termP oprP node =
  do infixL <- infixC termP oprP
     let (termOprs, term) = l2r infixL
     return (foldr (\(tl, opr) tr -> node opr tl tr) term termOprs)
-}

topLevelC :: Parser t a -> [t] -> a
topLevelC topLevelP toks =
  case parse topLevelP toks of
    [(v, [])] -> v
    [_]       -> error "grammar error (tokens remaining)"
    []        -> error "grammar error"
